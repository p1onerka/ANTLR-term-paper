% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{Обзор используемых технологий}

\subsubsection{OCaml}

\paragraph {Преимущества относительно императивных языков}

\begin{enumerate}
    \item Полезные для синтаксического анализа особенности функциональной парадигмы, в частности, более короткий и понятный код.
    \item Широкая распространенность в сфере синтаксического анализа.
    \item Высокая производительность благодаря компиляции в нативный код.
\end{enumerate}

\subsubsection{ANTLR}

\begin{enumerate}
    \item Архитектура
    
    ANTLR можно разделить на 3 логические части. 
    
    Первая включает в себя обработку исходного файла, в котором находится описание грамматики 
    (для четвертой версии ANTLR это файлы с типом .g4). 
    Результатом его является дерево абстрактного синтаксиса для лексического и синтаксического анализа. 
    В своей работе я не затрагиваю эту часть, она является общей для всех выходных языков.
    
    Вторая часть включает в себя генерацию файлов Lexer, Parser и нескольких вспомогательных файлов на основе деревьев
    абстрактного синтаксиса и специального шаблона из библиотеки StringTemplate (или рассказать про него тут же, а не в отдельном пункте?). 
    При помощи API, предоставляемого библиотекой, в шаблон подставляются значения из дерева абстрактного синтаксиса, что на выходе формирует
    полноценный файл на целевом языке.
    
    Однако в таком виде синтаксический анализатор еще не готов к работе. 
    Для обработки входной строки ему необходима третья часть инструмента: функциональность конечных автоматов, которая заранее должна быть 
    реализована внутри ANTLR в модуле Runtime. 
    Особенность модуля заключается в том, что он должен быть реализован полностью на целевом языке, и содержать все необходимые для 
    компиляции конфигурационные файлы. 
    Фактически, Runtime должен представлять собой полноценную библиотеку вспомогательных для синтаксического анализатора методов.  
    \item Библиотека StringTemplate

    Генерация файлов синтаксического и лексического анализаторов происходит посредством библиотеки StringTemplate. 
    С помощью нее можно создавать так называемые строковые шаблоны ~--- текст со специально обозначенными местами, в которые нужно 
    будет вставить некоторое поступившее значение. 
    Аргументы, которые будут подставляться в шаблон, называются атрибутами. 

    Библиотека StringTemplate предоставляет исчерпывающий API для взаимодействия с шаблонами, но в контексте ANTLR важнее всего метод add, 
    позволяющий по шаблону, от которого он вызывается, сгенерировать готовую строку с аргументами метода, подставленными вместо атрибутов. 

    Еще одной важной функциональностью в StringTemplate является создание групп шаблонов. 
    Это файлы с типом .stg, внутри которых можно объявить несколько взаимосвязанных шаблонов. 
    Внутри одной группы шаблоны могут подставляться друг в друга, передавая свои значения атрибутов в качестве аргументов внутреннему 
    шаблону. 
    Именно так и происходит создание синтаксического анализатора: генерация основного класса запускает множество вложенных генераций. 

    Таким образом, для добавления нового целевого языка необходимо описать группу шаблонов, на основе которых будет создаваться результат.
    \item Сравнение с другими аналогичными инструментами

    \begin{enumerate}
        \item В отличие от YACC и Bison, генерирующих LALR (lookahead left-to-right) анализаторы, ANTLR поддерживает LL(*) 
        (leftmost derivation с заглядыванием вперед на произвольное количество токенов). 
        Это позволяет корректно обрабатывать левую рекурсию, не делая при этом код слишком тяжеловесным и медленным. 
        (надо подробнее, в том числе объяснить значение терминов?)
        \item ANTLR ~--- самый популярный инструмент для генерации синтаксических анализаторов, и за время его существования накопилось 
        много материалов, помогающих разобраться в его работе. 
        Это выгодно выделяет его на фоне YACC, Bison, PEG.js и других менее популярных решений.
    \end{enumerate}

    \item (Добавить сюда еще пункт про описание работы конечных автоматов в ANTLR? Или излишне?)
\end{enumerate}

\subsubsection{Dune}

Модуль Runtime должен быть реализован на целевом языке, что, в случае OCaml, ставит вопрос о выборе системы сборки. 
Dune из всех возможных вариантов является самой популярной и легкой в использовании, наряду с make (вроде это не совсем система сборки?), 
OCamlBuild, Jbuilder и OASIS.
(расписать поподробнее, почему именно dune проста в использовании?)

\subsection{Обзор существующих решений}

\subsubsection{Реализованные языки ANTLR}

Текущая версия ANTLR (4.13.2 на момент 04.12.24) поддерживает генерацию парсеров в 10 языков программирования: 
C++, C\#, Dart, Java, JavaScript, PHP, Python версии 3, Swift, TypeScript и Go. 
Несмотря на наличие черт функциональной парадигмы в некоторых из них, все эти языки далеки по синтаксису и особенностям реализации от OCaml,
что делает затруднительным простой перевод готового анализатора с одного из имплементированных языков на выбранный целевой. 
Кроме того, для работы сгенерированный при помощи ANTLR анализатор требует специально реализованный на выходном языке модуль Runtime. 

Эти обстоятельства делают нецелесообразной идею использования ANTLR для OCaml-проекта без расширения текущей функциональности инструмента.

\subsection{Выводы}

На данный момент ANTLR является самым широко используемым генератором синтаксических анализаторов, в том числе, по причине удобства 
расширения. 
Библиотека StringTemplate помогает полностью освободить разработчика нового выходного языка от необходимости реализовывать все модули, 
связанные с первичной обработкой файла грамматики. 
Работа, таким образом, сводится к правильной настройке строкового шаблона и реализации модуля Runtime, необходимого для работы готового 
анализатора.